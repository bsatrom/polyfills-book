[[polyfills_chapter_6]]
== The Future of Polyfilling

So far in this book, we've discussed polyfilling in its original context: a strategy for "filling in the gaps" of older browsers with modern web APIs and technologies. In the last two chapters, I'd like to shift focus from the past and present and look instead at the future. Specifically, we'll talk about a variation of polyfilling that enables developers to experiment with not-yet-standardized APIs and developer-driven ideas that could potentially make their way into the browsers, in the future. In this chapter, I'll introduce that variation, prollyfilling, and will provides several examples of popular and notable prollyfilling libraries that push the boundaries of the Web Platform. Then, in Chapter 7, we'll wrap up this book with a  hands-on exploration of prollyfill construction, and how it compares to the exercise in Chapters 3-5.
  
=== Polyfilling: Not just for older browsers

As our browsers release updates at a faster and faster clip, and  legacy browsers like IE 6-8 decline in global use, it's easy to fall into the trap of thinking that polyfilling, as an idea, is becoming increasingly irrelevant. And while it's true that "classical" polyfills for popular HTML5 and CSS3 features are being used less and less, for every mainstream feature in the Web Platform, like CSS3 Animations, we're seeing 3-4 new ideas and technologies introduced via the W3C or WHATWG and landing in one or more browsers. HTML5 and friends may have modernized the web and our browsers in key ways, but don't think for a moment that they also brought feature parity along for the ride.

The bottom line: each new feature that's supported in Firefox but has yet to be implemented in Chrome, IE or Safari needs a polyfill just as much as that localStorage polyfill you're using for IE7 users. If newer technologies are to take off and become accepted by developers, we need to use them on actual sites. In some cases, we might take a "forked experience" approach and support the feature only where native to the browser. In many cases, however, new features bring capabilities that we wish to share with as many of our users as possible. In this case, pollyfilling is a must.

=== Prollyfilling: Extending the Web Forward

Of course, sometimes pollyfilling specified features isn't always enough for us, as web developers. We're a smart, ambitious bunch, and this is our platform too. Most of the time, we think we're just as qualified as browser vendors when it comes to determining what capabilities the web platform, and our  browsers, really need.

In Chapter 1, I mentioned something called the "Extensible Web Manifesto," a rallying cry of sorts, for front-end developers. It's one that calls us to "extend" the web forward by working on speculative and cutting edge ideas in our browsers. It also calls upon browser vendors to "unlock" low-level capabilities in the browsers (for instance, the browser's networking stack or HTML parser) and allow developers to write their own JavaScript libraries and APIs on top of those capabilities. The core idea that the manifesto argues for is that, with access to these low-level APIs, developers can experiment with real-world ideas their solve real-world problems. I use the phrase "real-world" here, because, on occasion, the W3C will pursue ideas that, while academically sound, are rejected by developers when subjected to actual use.

Take the oft-maligned Application Cache, for instance. This specification, which enjoys wide support across all modern desktop and mobile browsers, was introduced as a declarative API  intended to solve the very real problem of caching web sites an applications for offline use. It's a fantastic idea, and developers everywhere applauded the introduction of the technology when it was first introduced several years ago.

But the honeymoon didn't last long. After being subjected to real-world use on sites and applications of all sizes, developers discovered that AppCache (as it's called) was plagued  by a series of bugs and "bug-like features" that made the technology difficult or sometimes impossible to rely on. Ironically, while the Application Cache seemed well-suited for content-driven and static sites, it proved weakest when used for dynamic web-based applications.

If the authors and advocates of the Extensible Web Manifesto have their way, new technologies like Application Cache would not be introduced for full-blown standardization without first spending some time in the hands of developers. And by unlocking certain low-level browser APIs, like those mentioned above, developers can not only vet new ideas while in their infancy, but can also be a source of new ideas and feature proposals.

At it's core, this idea is referred to as "future polyfilling," or *prollyfilling,* the latter term being coined by Alex Sexton to describe building a polyfill for a not-yet-standardized API. Prollyfilling builds on the core ideas of polyfilling, building cross-browser functionality for developers to rely on, but places it square in the middle of the standardization process, which I believe will make the practice critical to the success of the Web Platform over the next decade.

=== Prollyfills in Action: Prollyfilling CSS

So what does a prollyfill look like, anyway? Well, it varies, and sometimes pretty widely. There are prollyfills in use today that not only provide experimental JavaScript APIs to developers, but which also allow developers to author custom HTML or CSS. We'll look at examples of all three types of prollyfills in this chapter, starting with a library that allows developers to try out experimental CSS features, and even create some of your own.

If you're a CSS aficionado, you know that there are some great new features on the horizon, like filter effects, grid layout, regions, exclusions, and more. Another exciting set of enhancements are being proposed in the [CSS Selectors Level 4]http://dev.w3.org/csswg/selectors4 specification, through which the CSS Working Group hopes to add a bevy of new, powerful selectors, while also upgrading some selectors introduced with CSS3.

For example, consider the new +:matches+ pseudo-class selector. This selector allows developers to group matching elements with simpler syntax than is possible currently. For instance, consider the following rule:

====
[source, css]
----
ul.tasks li a:link,
ul.tasks li a:hover,
ul.tasks li a:visited,
ul.tasks li a:focus {
   color: blue;
}
----
====

With the new +:matches+ pseudo-class selector, the rule above could be shortened, like so:

====
----
ul.tasks li a:matches(:link, :hover, :visited, :focus) {
   color: blue;
}
----
====

It's a simple change, but it greatly cleans up the authoring experience, while also making your CSS just a bit more readable, which is nice. 

+:matches+ is just one example of the great new CSS selectors in the Level 4 spec. Of course, the only problem is that we can't exactly try these experimental new selectors out for ourselves because they're still being discussed in the CSS Working Group and have not yet landed in any browser. But in the meantime, wouldn't it be great if we could actually start using new pseudo-class selectors like +:matches+ and even try out a few of our own? And not just to be early adopters, but to really try these new features on for size and see if they work as designed.

==== Using HitchJS to experiment with CSS

This sounds like a sweet spot for prollyfilling and, thankfully, there's a library available that allows you to experiment with CSS selectors, and even define your own. The library is called [HitchJS]http://hitchjs.com. Out of the box, Hitch provides support for a series of experimental selectors like +oneof+, +anyof+ and +allof+, and also provides a mechanism that allows you to define your own "hitches" that activate whatever CSS selectors you define. We'll create our own hitch in the next section, but first, let's take a look at how you can get started with Hitch and use some of the built-in features.

First things first, you'll need to download Hitch, which is distributed as a script file, and then include a reference to the file anywhere in your page:

====
[source, html]
----
<script src="js/hitch-0.6.3.min.js"></script>
----
====

Next, you can "activate" Hitch by decorating +<style>+ and +<link>+ tags with the +data-hitch-interpret+ attribute, which tells hitch to scan the CSS at the location for Hitch-specific selectors.

====
[source, html]
----
<link rel="stylesheet" href="css/styles.css" data-hitch-interpret>
----
====

In this example, I'm telling Hitch to look for rules in the +styles.css+ file. <<EX06-01>> contains the contents of that file.

[[EX06-01]]
.Custom CSS using HitchJS's built-in rules
====
[source, css]
----
#todo-list li:-hitch-anyof(.urgent, .overdue) label {
    color: red; 
}

#todo-list li:-hitch-noneof(.urgent, .overdue) label {
    color: green; 
}

#todo-list li:-hitch-allof(.urgent, .overdue) label {
    font-weight: bold; 
}
----
====

Notice the pseudo-class selectors that start with +-hitch-+. All three of these +-hitch-anyof+, +-hitch-noneof+ and +-hitch-allof+ are selectors that Hitch provides out of the box. +Anyof+ will  match any element in the comma-delimited list, +nonof+ is a negation selector that will only apply the rule if the +li+ has none of the classes in the list, and +allof+ is inclusive, only +li+ elements with both classes will match and apply the rule.

Now let's take a look at the source HTML, which is a list of todos decorated with classes where the todo is urgent, overdue or both:

[[EX06-02]]
.Todo list HTML
====
[source, html]
----
<ul id="todo-list">
	<li class="">
  	<div class="view">
    	<input class="toggle" type="checkbox">
      <label>Take out the trash</label>
    </div>
  </li>
  <li class="">
  	<div class="view">
    	<input class="toggle" type="checkbox">
      <label>Wash the cars</label>
    </div>
  </li>
  <li class="overdue">
  	<div class="view">
    	<input class="toggle" type="checkbox">
      <label>Buy stamps</label>
    </div>
  </li>
  <li class="urgent overdue">
  	<div class="view">
    	<input class="toggle" type="checkbox">
      <label>Pay taxes</label>
    </div>
  </li>
  <li class="urgent" id="next-action">
  	<div class="view">
    	<input class="toggle" type="checkbox">
      <label>Catch up on Breaking Bad</label>
    </div>
  </li>
</ul>
----
====

With everything in place, I should be able to load my todo list up and see the additional styling that my Hitch-based rules provide, as illustrated in <<EX06-03>>.

[[EX06-03]]
.Todo list with HitchJS-based styling
image::images/ch6-ex03.png[]

As you can see, HitchJS is easy to get started with and use in your own apps. By default, Hitch provides support for four logical selectors (+:-hitch-anyof+, +:-hitch-allof+, +:-hitch-oneof+, +-hitch-noneof+) and one structural selector (+:-hitch-has+), but the library also provides a great extensibility story so that you can create your own selector support in the form of "hitches" that are imported and processed by Hitch.js. In the next section, we'll create our own hitch to mimic a CSS Selectors Level 4 pseudo-element selector.

==== Building your own "hitches"

Earlier in this chapter, I introduced the new +:matches+ pseudo-class selector being considered for inclusion in the Selectors Level 4 spec. Rather than waiting for one or more browsers to implement support for this new selector, I'd like to try it on for size in my own apps--and possibly even share my experiences with other developers and members of the CSS Working Group. With Hitch, I can do that by creating a "hitch," or a JavaScript module that defines the logic for my selector. I then import my custom hitch into my app and when HitchJS is activated, it calls my module to determine if the element in question matches my custom selector.

So, to define my custom "hitch" for the CSS +:matches+ selector, I'll first need to create a new file called +selector-matches.js+ in my project. Then, I'll add the initial module definition that Hitch requires, as illustrated in <<EX06-04>>.

[[EX06-04]]
.Creating a Hitch for The Matches selector
====
[source, js]
----
var matchesHitch = {
    name: "matches",
    base: "*",
    type: "selector",
    filter: function(el, arguments){
        // Hitch logic here
    }
};
Hitch.add(matchesHitch);
----
==== 

The +matchesHitch+ object contains all of the properties that HitchJS requires when I define my own hitches. Most importantly, the +name+ represents the CSS selector value and the +filter+ represents a function that runs against every element that matches the base selector, but which needs to be filtered further by my hitch. This method should contain the core logic for my hitch and should return a boolean after I determine whether the element in question meets the filter criteria.

To emulate the CSS Selectors Level 4 +:matches+ pesudo-class selector, I'll need to test a comma-delimited string of class and Id values against an element, and if the element contains all of the values specified in the +:matches+ selector, I'll return true, at which point Hitch will apply the CSS defined inside my custom selector. The source for my Hitch's filter method can be found in <<EX06-05>>.

[[EX06-05]]
.Custom Matches Selector method in HitchJS
====
[source, js]
----
filter: function(el, selectorArgs){
	var i, len,
  	match = false,
    args = selectorArgs.split(','),
    list = el.parentElement;

	for (i = 0, len = args.length; i < len; i++) {
  	var q = list.querySelector(args[i].trim());
    if (q && q === el) {
    	match = true;
    } else {
    	match = false;
    }
  }
  return match;
}
----
===

After setting up some helper variables, I split my +selectorArgs+ variable, which contains the comma-delimited list of classes and Ids into an array. Then, I loop over that array and attempt to match each selector argument against the current element. If the element has all of the values defined in the +selectorArgs+ array, I'll return true.

Now that we have our custom hitch, let's try out our new rule in CSS. First, I'll need to "import" my hitch by using Hitch's +@-hitch-requires+ directive at the top of my +styles.css+ file:

====
[source, css]
----
@-hitch-requires ../js/selector-matches.js;
----
====

Then, I'll add a new rule using my hitch:

====
[source, css]
----
#todo-list li:matches(.urgent, #next-action) label {
    font-weight: bold; 
    color: blue;
}
----
====

With this rule, I'm instructing my custom hitch to look for any +li+ with a class of "urgent" and an Id of "next-action," and to style the +label+ for that +li+ to be bold and have a blue color. And with that, we have prollyfill-based support for the CSS +:matches+ rule, courtesy of HitchJS! The result can be seen in <<EX06-06>>.

[[EX06-06]]
.Our custom Hitch in action
image::images/ch6-ex06.png[]

HitchJS is a versatile library, and now that you've seen how easy it is to create your own hitches, you've got everything you need to try our experimental CSS features, or even prototype and play with your own!

=== Prollyfills in Action: ServiceWorker

In the last section, we explored how prollyfills can be useful for experimenting with new or unstable CSS selectors. Next, we'll shift focus to JavaScript prollyfilling. Specifically, we'll look at a proposal for one of those low-level APIs that could open up a wealth of new opportunities for front-end developers: [ServiceWorker]https://github.com/slightlyoff/ServiceWorker.

ServiceWorker is a proposal, spearheaded by Alex Russell of Google, designed to make the browser's networking stack more programmable via JavaScript. Specifically, a ServiceWorker enables developers to use script to cache and handle every inbound request for resources in an app, even when the user is offline. 

If you're thinking that this is starting to sound a lot like a JavaScript-based version of the oft-maligned Application Cache, you'd be right, and also wrong at the same time. Because ServiceWorker is meant to be a low-level API, it's far broader than an imperative AppCache. It can certainly be used to handle application asset and resource caching, but it's also far broader than that. In a very general sense a ServiceWorker is a script that, when installed in your app, listens for network events. When those events occur, a ServiceWorker can intercept the network request and serve cached resources before the browser ever attempts to connect to a remote server.

The first step in using a ServiceWorker is to install a worker on a page after a user visits for the first time. This means that the page, and all of its resources, will be served from the network at least once before the worker takes over. <<EX06-07>> shows and example of what the API for creating a new worker could look like:

[[EX06-07]]
.Creating a new ServiceWorker object
====
[source, html]
----
<!DOCTYPE html>
<!-- http://www.gifsemporium.com/index.html -->
<html>
  <head>
    <link rel="stylesheet" href="/css/base.css">
    <script src="/js/app.js"></script>
		<script>
      navigator.registerServiceWorker("/*", "sWorker.js").then(
        function(serviceWorker) {
          // Use the worker right away
          window.location.reload();
        },
        function(err) {
          console.error("Worker install failed:", err);
        });
    </script>
  </head>
  <body>
    <img src="/images/logo.gif" alt="Gif Emporium Logo">
		<h1>Animated Gifs Galore!</h1>
  </body>
</html>
----
====

The key snippet here is the call to +navigator.registerServiceWorker+ which takes two parameters, a route or set of routes to handle with our service worker, and the path to a JavaScript file that contains the worker logic. The API is also promise-based, so I can call +then()+ on the API with success and error handlers and notify the system of a successful or failed worker registration. 	A sample +sWorker.js+ file can be found in <<EX06-08>>.

[[EX06-08]]
.A sample ServiceWorker controller
====
[source, js]
----
// hosted at: js/sWorker.js

var base = "http://www.gifsemporium.com";
var inventory = new URL("/services/gifs.json", base);

this.addEventListener("install", function(e) {
  // this worker can handle fetch events
  e.services = ["fetch"];
});

this.addEventListener("fetch", function(e) {
  var url = e.request.url;
  // If we already have the data, load from cache
	if (url.toString() == inventory.toString()) {
    e.respondWith(new SameOriginResponse({
      statusCode: 200,
      body: JSON.stringify({
        gifs: { /* ... */ }
      })
    }));
  }
});
----
====

The ServiceWorker exposes several events that workers can respond to if they wish. If a worker is installed and has registered a +fetch+ listener, as we have above, the worker is allowed to handle the network request on behalf of the browser. In this case, we're checking to see if the URL being requested matches an existing resource and, if so, we'll use the new +respondWith+ method on the +fetch+ event to construct a cached response containing the data requested by the browser, and the network never even needs to be consulted!

The public API for the ServiceWorker proposal can be found in a [TypeScript file in the project's GitHub repository]https://github.com/slightlyoff/ServiceWorker/blob/master/service_worker.ts, and I also recommend checking out the [explainer document]https://github.com/slightlyoff/ServiceWorker/blob/master/explainer.md put together by the works working on the proposal. It's early days for ServiceWorker, which doesn't yet enjoy browser support, but the proposal is exactly the kind of API described in the Extensible Web Manifesto: a set of low-level browser capabilities that provide developers with ground-floor access to building robust, JavaScript-based prollyfills and APIs that push the web forward faster than ever.

=== Prollyfills in Action: Web Components


==== Creating Custom Elements with Angular JS


==== Creating Custom Elements with Polymer


=== Strategies for polyfilling experimental APIs


Now that we've explored the ins and outs of prollyfilling, and some high-level strategies for building our own prollyfills, let's do exactly that.
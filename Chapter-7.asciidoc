[[polyfills_chapter_7]]
== Building Your First Prollyfill

In Chapters 3-5, I walked you through the exercise of building a polyfill for the HTML5 Forms spec. Over the course of those three chapters, we talked about how to make a plan for building a polyfill, how to go about initial development, how to configure your library for automated and cross-browser testing and, finally, how to build your polyfill for performance. 

In Chapter 6, I introduced the concept of the prollyfill, and walked through several examples of popular prollyfilling libraries. In this chapter, we're going to build on that knowledge, along with what we learned earlier in the book, and build our own prollyfill to "test out" an experimental Web Platform feature. Along the way, you'll learn both the ways that building polyfills and prollyfills are similar, and the ways they differ.

=== Prollyfills vs. Polyfills: What's the Difference?

Prollyfills, as we discussed in Chapter 6, are quite similar to polyfills in many ways, the biggest exception being that they often target proposals or specifications with in-flux APIs. Sometimes they even target untested or unspecified ideas, altogether. In both cases, much of the ideas that surround the polyfill, including the API, are expected to change greatly as the idea is debated, tested and possibly accepted for standardization.

The purpose of building a prolyfill differs from that of a polyfill. Polyfills are typically built to allow developers to rely on new features and APIs across all browsers. They are meant, for the most part, to be used in production apps by everyday developers. Prollyfills, on the other hand, are different. In many ways, these libraries are experiments. They are built to test out unproven concepts, or ideas for standardization that need developer feedback or real-world application. Prollyfills are, for the most part, meant to be used in development and test settings, and not in production apps.

That key difference between prollyfills and polyfills--their purpose for being--can tell us a great deal about how these libraries can and should be built by developers. As you'll see in this chapter, much of the construction process remains the same. You'll still want to set up unit tests, cross-browser tests and plan out the scope of your library, but you'll also need to build flexibility into the API of your library, which you should expect to change. You'll want to pay attention to performance, of course, but it's less critical with a prollyfill since these libraries are meant to test ideas. Often, prollyfills will lead you down a path of non-performant implementations in order to test out ideas, as you'll see in this chapter, and that's perfectly ok.

=== The Resource Priorities Prollyfill

For the rest of this chapter, we're going to go through a brief exercise and build our own prollyfill for a brand-new W3C proposal. The name of the specification we'll be targeting is [Resource Priorities]https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html. Resource Priorities are meant to provide developers with new HTML attributes and a CSS property that can be used to specify the download priority of a resource like an image, script or media element. The two attributes and property are:

- [lazyload]https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-lazyload - A boolean HTML attribute that tells the browser to delay loading the element in question until all elements that do not have this attribute have started downloading.
- [postpone]https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-postpone - A boolean HTML attribute that tells the browser to delay loading the element in question until the element or it's container are visible in the viewport.
- [resource-priorities]https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-postpone - A CSS property that can be used to set the resource priority (lazyload or postpone) of a resource associated with an element or another CSS property.

Of course, you're probably wondering what the point of this spec is, especially in light of HTML5's +defer+ and +async+ attributes. For starters, +defer+ and +async+ are available only to +script+ elements, whereas +lazyload+ and +postpone+ are available to all HTML elements that can download resources, including +script+, +link+, +img+, +audio+, +video+, +iframe+, and more. 

More importantly, though, resource priorities provide developers with a way to programmatically give the browser hints as to the importance of resources. At the present, download priority for the browser is based solely on document order--scripts, stylesheets and images are loaded in the order that they appear--but document order, especially for visual resources, is often more a function of document location and not resource importance. As a result, it's difficult for developers to control the real and perceived performance of their pages without script-based hacks.

Let's take a look at an example. The page in <<EX07-01>> contains several resources: two stylesheets, a video, several images and a few scripts. The way this document is structured, all media will be downloaded in document order, and our script at +app.js+, which presumably is important to the function of the page, won't start executing until those downloads have at least initiated. What's more, if our +app.js+ script is relying on a +document.load+ event or jQuery's +load+ event, our application script won't load until those resources have been loaded.

[[EX07-01]]
.An example HTML page with document-order prioritized resources
====
[source, html]
----
<!DOCTYPE html>
<html>
 <head>
     <link rel="stylesheet" type="text/css" src="styles.css" />
     <link rel="stylesheet" type="text/css" src="animations.css" />
		<style>
			video.promo source {
				resource-priorities: postpone;
			}
		</style>
 </head>
 <body>
    <img id="siteLogo" src="/images/site.png"/>
    <img id="Header" src="/images/Header.png"/>
		<ul class="gallery">
    	<li>
				<img id="img1" src=".../images/img1.png" />
			</li>
    	<li>
				<img id="img3" src=".../images/img2.png" />
			</li>
			<li>
				<img id="img3" src=".../images/img3.png" />
			</li>
		</ul>
		<video class="promo">
			<source src="/videos/promo.mp4">
			<source src="/videos/promo.ogv">
			<source src="/videos/promo.webm">
		</video>
    <script src="app.js" ></script>
    <script src="GoogleAnalytics.js"></script>
 </body>
</html>
----
====

The +lazyload+ and +postpone+ properties provide us an alternative that allow us to preserve our page structure, while also providing programmatic hints as to the importance of page resources. Elements with +lazyload+ and +postpone+ will be loaded either when all other resources have been loaded or when the viewport enters the bounding box of the element in question, respectively. Elements without either of these properties, on the other hand, will continue to load in document order, as before. <<EX07-02>> shows an example of these features, in action.

[[EX07-02]]
.An example HTML page with prioritized resources
====
[source, html]
----
<!DOCTYPE html>
<html>
 <head>
     <link rel="stylesheet" type="text/css" src="styles.css" />
     <link rel="stylesheet" type="text/css" src="animations.css" lazyload />
		<style>
			video.promo source {
				resource-priorities: postpone;
			}
		</style>
 </head>
 <body>
    <img id="siteLogo" src="/images/site.png"/>
    <img id="Header" src="/images/Header.png"/>
		<ul class="gallery">
    	<li>
				<img id="img1" src=".../images/img1.png" lazyload />
			</li>
    	<li>
				<img id="img3" src=".../images/img2.png" postpone />
			</li>
			<li>
				<img id="img3" src=".../images/img3.png" postpone />
			</li>
		</ul>
		<video class="promo">
			<source src="/videos/promo.mp4">
			<source src="/videos/promo.ogv">
			<source src="/videos/promo.webm">
		</video>
    <script src="app.js" ></script>
    <script src="GoogleAnalytics.js" lazyload></script>
 </body>
</html>
----
====

In the sample above, which will also serve as our base demo page for the prollyfill, you can see both attributes and the property in action. First, in the style tag, we have a single CSS selector for the source values of any video tags containing the class "promo." Inside of the selector is our +resource-priorities+ property, which tells the browser to set the +postpone+ value on the video source elements. As you'll recall,   postpone indicates to the browser that resources are not to be loaded until visible on the screen, so this CSS rule will ensure that the video on my page doesn't begin loading until the user scrolls to that location on the screen.

Throughout the rest of the sample above, I've applied the +lazyload+ attribute to those resources that I want to have downloaded as soon as core page resources are loaded, and the +postpone+ attribute to those resources that need to only be loaded when in the user's visible viewport. The end result is a page with clear instructions to the browser as to the loading priority of all resources in the document. 

Resource Priorities are a great idea, but since they are so new, there aren't any native browser implementations. Instead, we can build our own prollyfill, which will allow us, and other developers to put this spec through its paces and offer feedback to spec authors and the W3C. So let's start building our prollyfill, which I've decided to call slacker.js.

=== Specifying the API & Deciding What to Build

Before beginning construction of our prollyfill, it's important to take a moment and consider the purpose and goals of the project, what you will and won't take on, as well as the API of the library. As I did in Chapter 2 with the Kendo UI Forms polyfill, the first thing I did with +https://github.com/bsatrom/slacker.js[slacker.js]+ was to define the purpose and goals of the project, as illustrated in <<EX07-03>>.

[[EX07-03]]
.Purpose and Goals of the Resource Priorities prollyfill, slacker.js
____
== Purpose & Goals

The purpose of this project is to serve as a complete prolyfill for the draft https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-postpone[Resource Priorities spec], including support for new HTML attributes (+lazyload+ and +postpone+), a new CSS property (+resource-priorities+) and a DOM event (+lazyloaded+). This project includes built-in feature detection and, by-default, will only polyfill those forms features not present in the user's browser. 

As a prollyfill, this library's primary purpose is to serve as a proof-of-concept and testbed for conversations around the Resource Priorities specification, and *not* to serve as a cross-browser polyfill ready for production use.

This library will function as both a drop-in and opt-in prollyfill, depending on the features being used. For the +lazyload+ and +postpone+ properties, this library will automatically detect and manage these resources when included in a document. When using the +resource-priorities+ CSS property, +link+ and +style+ elements should be decorated with an attribute (+data-slacker-interpret+) that will indicate use of this property to the prollyfill.

*Goals*

- **Provide a complete Resource Priorities solution that allows developers to experiment with new attributes, CSS properties and DOM events, as defined in the spec**.
- **Provide a test bed for specified and experimental features**. As a prollyfill, the API surface of this library is not limited to those features already contained in the spec. Where it makes sense to propose new or changed features, this library can be used as a POC for those proposed changes.
- **Adapt quickly to specification changes, including those to the spec's API**. We expect this spec to change, and this library should be built in such a way that API changes are easy to absorb.

*Non-Goals*

- This library is intended to serve as a proof-of-contept for a cutting-edge web platform feature and, as such is not meant for production use. 
- As a proof-of-concept, this library will not be performance-tuned
- This library may diverge from the https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-postpone[Resource Priorities spec] in order to add convenience features, non-standard behaviors, or to add experimental APIs for consideration by spec authors.
____

As you can see, this section has a lot of similarities to and differences from our Forms polyfill. Like the Forms library, this section contains a summary of the purpose of the project, as well as a few bullets covering the goals and non-goals of the project. The differences are clear in the content, however. Our prollyfill is an experiment intended to drive discussion, and you can see that reflected in the text above.

Once I've clearly defined the purpose and goals of my library, I'll turn my attention next to its API. For this, I like to sit down with the spec and draft a features matrix so that I can outline the major features my library should provide, as well as any feature-specific caveats or quirks that the library should account for. <<EX07-04>> illustrates my initial features matrix for +slacker.js+.

[[EX07-04]]
.Features Matrix for +slacker.js+
[options="header"]
|==============================================
|Feature|Opt-In|Workflow|Exceptions|Supported Elements
|Support for +lazyload+ attribute|No|Remove +src+ of elements with +lazyload+ and place in an array; When +document.load+ is fired, re-set the +src+ for each element.|for +script+, if +defer+ is used with +lazyload+, it has no effect; for +script+, if +async+ is set to false, +lazyload+ has no effect; for +svg reImage+, if +externalResourcesRequired+ is set to "true," +lazyload+ has no effect|+img+, +audio+, +video+, +script+, +link+, +embed+, +iframe+, +object+, +svg feImage+, +svg use+, +svg script+, +svg tref+  
|Support for +postpone+ attrbute|No|Remove +src+ of elements with +postpone+ and place in an array; On scroll or when an element with the +display:none+ property becomes visible, determine if any elements are within the bounding box of the page and, if so, re-set the +src+ for each visible element.|for +audio+, +postpone+ only works if the +controls+ attribute has been set; for +svg reImage+, if +externalResourcesRequired+ is set to "true," +postpone+ has no effect|+img+, +audio+, +video+, +script+, +link+, +embed+, +iframe+, +object+, +svg feImage+, +svg use+, +svg script+, +svg tref+  
|Support for +resource-priorities+ CSS property|Yes (+data-slacker-interpret+)|Parse all +link+ and +style+ elements that use the +data-slacker-interpret+ attribute and find all instances of the +resource-priorities+ property; Remove +src+ values for related elements, and any CSS properties that specify a source (like +background-image+)|None|+img+, +audio+, +video+, +script+, +link+, +embed+, +iframe+, +object+, +svg feImage+, +svg use+, +svg script+, +svg tref+, '+background-image+', '+border-image-source+', '+content+', '+cursor+', '+list-style-image+', '+@font-face src+'  
|Support for +lazyloaded+ event|No|Once the +src+ has been re-set for resources with the +lazyload+ attribute, fire the +lazyloaded+ event. If no such elements exist, fire immediately after +document.load+|None| N/A
|==============================================

As you can see from the table above, even though there are really only four major features to the Resource Priorities spec, there's quite a lot going on for what seems like a relatively straightforward prollyfill. In addition to needing to support new attributes, a CSS proper and a DOM event, we have to consider how to support these new features across a dozen HTML elements and a handful of resource-loading CSS properties. We also have to take into account the interaction between +lazyload+/+postpone+ and +defer+ and +async+ when used on script elements. Since there's a lot to consider when building my prollyfill, I'm going to create a roadmap for major features, just as I did for my HTML5 Forms polyfill. The roadmap for +slacker.js+ can be seen in <<EX07-05>>.

[[EX07-05]]
.Roadmap for slacker.js
____
== Prollyfill Roadmap

- v0.1 - Support for the +lazyload+ attribute and +lazyloaded+ event
- v0.2 - Support for the +postpone+ attribute
- v0.5 - Support for the +resource-priorities+ CSS property
- v1.0 - Full spec support (v0.5 + bug-fixes needed)
____

With a clearly defined set of goals, features and a roadmap for my library, I'm not ready to get started. In the next section, we'll set up the initial project for +slacker.js+ and start building out our polyfill.

=== Setting Up Your Prollyfill Project



=== Adding the first test & Feature



=== Adding Features

=== Testing

==== Automated Testing

==== Testing Across Browsers

=== Building for Performance
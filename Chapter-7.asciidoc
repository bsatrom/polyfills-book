[[polyfills_chapter_7]]
== Building Your First Prollyfill

In Chapters 3-5, I walked you through the exercise of building a polyfill for the HTML5 Forms spec. Over the course of those three chapters, we talked about how to make a plan for building a polyfill, how to go about initial development, how to configure your library for automated and cross-browser testing and, finally, how to build your polyfill for performance. 

In Chapter 6, I introduced the concept of the prollyfill, and walked through several examples of popular prollyfilling libraries. In this chapter, we're going to build on that knowledge, along with what we learned earlier in the book, and build our own prollyfill to "test out" an experimental Web Platform feature. Along the way, you'll learn both the ways that building polyfills and prollyfills are similar, and the ways they differ.

=== Prollyfills vs. Polyfills: What's the Difference?

Prollyfills, as we discussed in Chapter 6, are quite similar to polyfills in many ways, the biggest exception being that they often target proposals or specifications with in-flux APIs. Sometimes they even target untested or unspecified ideas, altogether. In both cases, much of the ideas that surround the polyfill, including the API, are expected to change greatly as the idea is debated, tested and possibly accepted for standardization.

The purpose of building a prolyfill differs from that of a polyfill. Polyfills are typically built to allow developers to rely on new features and APIs across all browsers. They are meant, for the most part, to be used in production apps by everyday developers. Prollyfills, on the other hand, are different. In many ways, these libraries are experiments. They are built to test out unproven concepts, or ideas for standardization that need developer feedback or real-world application. Prollyfills are, for the most part, meant to be used in development and test settings, and not in production apps.

That key difference between prollyfills and polyfills--their purpose for being--can tell us a great deal about how these libraries can and should be built by developers. As you'll see in this chapter, much of the construction process remains the same. You'll still want to set up unit tests, cross-browser tests and plan out the scope of your library, but you'll also need to build flexibility into the API of your library, which you should expect to change. You'll want to pay attention to performance, of course, but it's less critical with a prollyfill since these libraries are meant to test ideas. Often, prollyfills will lead you down a path of non-performant implementations in order to test out ideas, as you'll see in this chapter, and that's perfectly ok.

=== The Resource Priorities Prollyfill

For the rest of this chapter, we're going to go through a brief exercise and build our own prollyfill for a brand-new W3C proposal. The name of the specification we'll be targeting is [Resource Priorities]https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html. Resource Priorities are meant to provide developers with new HTML attributes and a CSS property that can be used to specify the download priority of a resource like an image, script or media element. The two attributes and property are:

- [lazyload]https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-lazyload - A boolean HTML attribute that tells the browser to delay loading the element in question until all elements that do not have this attribute have started downloading.
- [postpone]https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-postpone - A boolean HTML attribute that tells the browser to delay loading the element in question until the element or it's container are visible in the viewport.
- [resource-priorities]https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-postpone - A CSS property that can be used to set the resource priority (lazyload or postpone) of a resource associated with an element or another CSS property.

Of course, you're probably wondering what the point of this spec is, especially in light of HTML5's +defer+ and +async+ attributes. For starters, +defer+ and +async+ are available only to +script+ elements, whereas +lazyload+ and +postpone+ are available to all HTML elements that can download resources, including +script+, +link+, +img+, +audio+, +video+, +iframe+, and more. 

More importantly, though, resource priorities provide developers with a way to programmatically give the browser hints as to the importance of resources. At the present, download priority for the browser is based solely on document order--scripts, stylesheets and images are loaded in the order that they appear--but document order, especially for visual resources, is often more a function of document location and not resource importance. As a result, it's difficult for developers to control the real and perceived performance of their pages without script-based hacks.

Let's take a look at an example. The page in <<EX07-01>> contains several resources: two stylesheets, a video, several images and a few scripts. The way this document is structured, all media will be downloaded in document order, and our script at +app.js+, which presumably is important to the function of the page, won't start executing until those downloads have at least initiated. What's more, if our +app.js+ script is relying on a +document.load+ event or jQuery's +load+ event, our application script won't load until those resources have been loaded.

[[EX07-01]]
.An example HTML page with document-order prioritized resources
====
[source, html]
----
<!DOCTYPE html>
<html>
 <head>
     <link rel="stylesheet" type="text/css" src="styles.css" />
     <link rel="stylesheet" type="text/css" src="animations.css" />
		<style>
			video.promo source {
				resource-priorities: postpone;
			}
		</style>
 </head>
 <body>
    <img id="siteLogo" src="/images/site.png"/>
    <img id="Header" src="/images/Header.png"/>
		<ul class="gallery">
    	<li>
				<img id="img1" src=".../images/img1.png" />
			</li>
    	<li>
				<img id="img3" src=".../images/img2.png" />
			</li>
			<li>
				<img id="img3" src=".../images/img3.png" />
			</li>
		</ul>
		<video class="promo">
			<source src="/videos/promo.mp4">
			<source src="/videos/promo.ogv">
			<source src="/videos/promo.webm">
		</video>
    <script src="app.js" ></script>
    <script src="GoogleAnalytics.js"></script>
 </body>
</html>
----
====

The +lazyload+ and +postpone+ properties provide us an alternative that allow us to preserve our page structure, while also providing programmatic hints as to the importance of page resources. Elements with +lazyload+ and +postpone+ will be loaded either when all other resources have been loaded or when the viewport enters the bounding box of the element in question, respectively. Elements without either of these properties, on the other hand, will continue to load in document order, as before. <<EX07-02>> shows an example of these features, in action.

[[EX07-02]]
.An example HTML page with prioritized resources
====
[source, html]
----
<!DOCTYPE html>
<html>
 <head>
     <link rel="stylesheet" type="text/css" src="styles.css" />
     <link rel="stylesheet" type="text/css" src="animations.css" lazyload />
		<style>
			video.promo source {
				resource-priorities: postpone;
			}
		</style>
 </head>
 <body>
    <img id="siteLogo" src="/images/site.png"/>
    <img id="Header" src="/images/Header.png"/>
		<ul class="gallery">
    	<li>
				<img id="img1" src=".../images/img1.png" lazyload />
			</li>
    	<li>
				<img id="img3" src=".../images/img2.png" postpone />
			</li>
			<li>
				<img id="img3" src=".../images/img3.png" postpone />
			</li>
		</ul>
		<video class="promo">
			<source src="/videos/promo.mp4">
			<source src="/videos/promo.ogv">
			<source src="/videos/promo.webm">
		</video>
    <script src="app.js" ></script>
    <script src="GoogleAnalytics.js" lazyload></script>
 </body>
</html>
----
====

In the sample above, which will also serve as our base demo page for the prollyfill, you can see both attributes and the property in action. First, in the style tag, we have a single CSS selector for the source values of any video tags containing the class "promo." Inside of the selector is our +resource-priorities+ property, which tells the browser to set the +postpone+ value on the video source elements. As you'll recall,   postpone indicates to the browser that resources are not to be loaded until visible on the screen, so this CSS rule will ensure that the video on my page doesn't begin loading until the user scrolls to that location on the screen.

Throughout the rest of the sample above, I've applied the +lazyload+ attribute to those resources that I want to have downloaded as soon as core page resources are loaded, and the +postpone+ attribute to those resources that need to only be loaded when in the user's visible viewport. The end result is a page with clear instructions to the browser as to the loading priority of all resources in the document. 

Resource Priorities are a great idea, but since they are so new, there aren't any native browser implementations. Instead, we can build our own prollyfill, which will allow us, and other developers to put this spec through its paces and offer feedback to spec authors and the W3C. So let's start building our prollyfill, which I've decided to call slacker.js.

=== Specifying the API & Deciding What to Build

Before beginning construction of our prollyfill, it's important to take a moment and consider the purpose and goals of the project, what you will and won't take on, as well as the API of the library. As I did in Chapter 2 with the Kendo UI Forms polyfill, the first thing I did with +https://github.com/bsatrom/slacker.js[slacker.js]+ was to define the purpose and goals of the project, as illustrated in <<EX07-03>>.

[[EX07-03]]
.Purpose and Goals of the Resource Priorities prollyfill, slacker.js
____
== Purpose & Goals

The purpose of this project is to serve as a complete prolyfill for the draft https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-postpone[Resource Priorities spec], including support for new HTML attributes (+lazyload+ and +postpone+), a new CSS property (+resource-priorities+) and a DOM event (+lazyloaded+). This project includes built-in feature detection and, by-default, will only polyfill those forms features not present in the user's browser. 

As a prollyfill, this library's primary purpose is to serve as a proof-of-concept and testbed for conversations around the Resource Priorities specification, and *not* to serve as a cross-browser polyfill ready for production use.

This library will function as both a drop-in and opt-in prollyfill, depending on the features being used. For the +lazyload+ and +postpone+ properties, this library will automatically detect and manage these resources when included in a document. When using the +resource-priorities+ CSS property, +link+ and +style+ elements should be decorated with an attribute (+data-slacker-interpret+) that will indicate use of this property to the prollyfill.

*Goals*

- **Provide a complete Resource Priorities solution that allows developers to experiment with new attributes, CSS properties and DOM events, as defined in the spec**.
- **Provide a test bed for specified and experimental features**. As a prollyfill, the API surface of this library is not limited to those features already contained in the spec. Where it makes sense to propose new or changed features, this library can be used as a POC for those proposed changes.
- **Adapt quickly to specification changes, including those to the spec's API**. We expect this spec to change, and this library should be built in such a way that API changes are easy to absorb.

*Non-Goals*

- This library is intended to serve as a proof-of-contept for a cutting-edge web platform feature and, as such is not meant for production use. 
- As a proof-of-concept, this library will not be performance-tuned
- This library may diverge from the https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html#attr-postpone[Resource Priorities spec] in order to add convenience features, non-standard behaviors, or to add experimental APIs for consideration by spec authors.
____

As you can see, this section has a lot of similarities to and differences from our Forms polyfill. Like the Forms library, this section contains a summary of the purpose of the project, as well as a few bullets covering the goals and non-goals of the project. The differences are clear in the content, however. Our prollyfill is an experiment intended to drive discussion, and you can see that reflected in the text above.

Once I've clearly defined the purpose and goals of my library, I'll turn my attention next to its API. For this, I like to sit down with the spec and draft a features matrix so that I can outline the major features my library should provide, as well as any feature-specific caveats or quirks that the library should account for. <<EX07-04>> illustrates my initial features matrix for +slacker.js+.

[[EX07-04]]
.Features Matrix for +slacker.js+
[options="header"]
|==============================================
|Feature|Opt-In|Workflow|Exceptions|Supported Elements
|Support for +lazyload+ attribute|No|Remove +src+ of elements with +lazyload+ and place in an array; When +document.load+ is fired, re-set the +src+ for each element.|for +script+, if +defer+ is used with +lazyload+, it has no effect; for +script+, if +async+ is set to false, +lazyload+ has no effect; for +svg reImage+, if +externalResourcesRequired+ is set to "true," +lazyload+ has no effect|+img+, +audio+, +video+, +script+, +link+, +embed+, +iframe+, +object+, +svg feImage+, +svg use+, +svg script+, +svg tref+  
|Support for +postpone+ attrbute|No|Remove +src+ of elements with +postpone+ and place in an array; On scroll or when an element with the +display:none+ property becomes visible, determine if any elements are within the bounding box of the page and, if so, re-set the +src+ for each visible element.|for +audio+, +postpone+ only works if the +controls+ attribute has been set; for +svg reImage+, if +externalResourcesRequired+ is set to "true," +postpone+ has no effect|+img+, +audio+, +video+, +script+, +link+, +embed+, +iframe+, +object+, +svg feImage+, +svg use+, +svg script+, +svg tref+  
|Support for +resource-priorities+ CSS property|Yes (+data-slacker-interpret+)|Parse all +link+ and +style+ elements that use the +data-slacker-interpret+ attribute and find all instances of the +resource-priorities+ property; Remove +src+ values for related elements, and any CSS properties that specify a source (like +background-image+)|None|+img+, +audio+, +video+, +script+, +link+, +embed+, +iframe+, +object+, +svg feImage+, +svg use+, +svg script+, +svg tref+, '+background-image+', '+border-image-source+', '+content+', '+cursor+', '+list-style-image+', '+@font-face src+'  
|Support for +lazyloaded+ event|No|Once the +src+ has been re-set for resources with the +lazyload+ attribute, fire the +lazyloaded+ event. If no such elements exist, fire immediately after +document.load+|None| N/A
|==============================================

As you can see from the table above, even though there are really only four major features to the Resource Priorities spec, there's quite a lot going on for what seems like a relatively straightforward prollyfill. In addition to needing to support new attributes, a CSS proper and a DOM event, we have to consider how to support these new features across a dozen HTML elements and a handful of resource-loading CSS properties. We also have to take into account the interaction between +lazyload+/+postpone+ and +defer+ and +async+ when used on script elements. Since there's a lot to consider when building my prollyfill, I'm going to create a roadmap for major features, just as I did for my HTML5 Forms polyfill. The roadmap for +slacker.js+ can be seen in <<EX07-05>>.

[[EX07-05]]
.Roadmap for slacker.js
____
== Prollyfill Roadmap

- v0.1 - Support for the +lazyload+ attribute and +lazyloaded+ event
- v0.2 - Support for the +postpone+ attribute
- v0.5 - Support for the +resource-priorities+ CSS property
- v1.0 - Full spec support (v0.5 + bug-fixes needed)
____

With a clearly defined set of goals, features and a roadmap for my library, I'm now ready to get started. In the next section, we'll set up the initial project for +slacker.js+ and start building out our polyfill.

=== Setting Up Your Prollyfill Project

In Chapter 3, I provided some tips on how to set up the initial project structure for your polyfill, including essential documentation files (README, LICENSE, CHANGELOG, CONTRIBUTING) and essential directories for your source, 3rd party dependencies, tests and distribution files. In Chapter 4, we expanded on this list with a discussion on configuring project builds with Grunt and setting-up unit and cross-browser testing via Jasmine, Karma and Travis.ci. For a probablyfill, much of these process remains the same, so I won't repeat it here. Instead, I encourage you to check out Chapter 3 and 4 if you haven't already to get an overview of how I've chosen to configure both my HTML5 Forms polyfill and my Resource Priorities prollyfill.

=== Adding Prollyfill Features

For +slacker.js+, I'm going to use http://pivotal.github.io/jasmine/[Jasmine] for my unit tests, just as I did for the HTML5 Forms polyfill earlier in the book. Once I've configured Jasmine, including the Grunt- and Karma-dependent steps outlined in Chapter 4, I'm ready to add my first test.

==== The First Test: Feature Detection

In the roadmap for my prollyfill, which I shared above, I decided to first focus on supporting the +lazyload+ attribute. Along those lines, my first test make sure that my prollyfill is performing feature detection for the +lazyload+ attribute. I know, of course, that now browser currently supports this attribute, but I don't know how long that will be the case, or how long my library will stick around, so the responsible thing to do is to always perform feature detection, if possible, even when building prollyfills. <<EX07-06>> contains the source for my first test:

[[EX07-06]]
.First test for the slacker.js prollyfill
====
[source, js]
----
describe('lazyload attribute tests', function() {
  it('should test for the lazyload attribute before acting',
  function() {
    var s = document.createElement('script');
    var lazyloadSupported = 'lazyload' in s;

    expect(lazyloadSupported)
			.toEqual(window.slacker.features.lazyload);
  });
});
----
====

When I first run this test, it will fail, of course. In order to make it pass, I'll add a test for the +lazyload+ attribute to my source in a new file called +slacker.features.js+, as shown in <<EX07-07>>.

[[EX07-07]]
.+lazyload+ feature test
====
[source, js]
----
(function() {
  window.slacker = window.slacker || {};

  var resourcePrioritiesFeatures = {
    lazyload: (function () {
      var s = document.createElement('script');
      return 'lazyload' in s;
    })()
  };
  
  window.slacker.features = resourcePrioritiesFeatures;
}());
----
====

This module, which will serve as the core module for all feature tests in my prollyfill, starts with an IIFE before setting the global +window.slacker+ namespace that I'll be using for my prollyfill. Next, I create an object literal to hold my feature tests, and add a test for the +lazyload+. As discussed in Chapter 3, I can test for official support for new HTML attributes by creating an in-memory element and checking to see if the attribute exists. Once I've added my features module and the +lazyload+ test, my first test should pass.

==== The Second Test: Initial +lazyload+ functionality

Now that I have my feature testing in place, I can shift to the +lazyload+ attribute itself. The next test, as illustrated in <<EX07-08>> will make sure that my prollyfill detects the presence of this attribute and removes whatever value is specified in the src.

[[EX07-08]]
.Testing +src+ attribute removal
====
[source, js]
----
it('should detect the lazyload attribute and remove the src attribute', function() {
  fixtures.load('lazyload.html');

  var stylesheet = document.querySelectorAll('[lazyload]');

  expect(stylesheet.length).not.toBe(0);
  expect(stylesheet[0].getAttribute('src')).toEqual('');
});
----
====

The +lazyload.html+ file referenced at the start of the test is a simple document containing two +link+ elements, one of which has been decorated with the +lazyload+ attribute. For this test, that file is loaded and added to the virtual DOM and then selected from the document, at which point I use a couple of Jasmine +expect+ calls to make sure that a) the element is in the DOM and b) it's +src+ attribute has been modified.

As with our first test, this test will fail on first run because I haven't added any functionality yet. Let's do that, first by creating a +slacker.js+ source file in the +src+ directory for my project, and then by adding the +src+ removal functionality, as illustrated in <<EX07-09>>.

[[EX07-09]]
.Creating the +lazyload+ src removal feature
====
[source, js]
----
(function() {
  window.slacker = window.slacker || {};

  var i, len,
    lazyLoaded = [],
    qsa = document.querySelectorAll;

  //Test for the presence of the lazyload attribute.
  //If it's not supported, let's get to work.
  if (!window.slacker.features.lazyload){
    var elements = qsa('[lazyload]');

    for (i = 0, len = elements.length; i < len; i++) {
      var el = elements[i];
      lazyLoaded.push(el.getAttribute('src'));
      el.setAttribute('src','');
    }
  }

}());
----
====

[HERE]

=== Adding Features

=== Testing

==== Automated Testing

==== Testing Across Browsers

=== Building for Performance

As I mentioned earlier in this chapter, when building a prollyfill, your goal is to build something that tests out a experimental API, not to build something meant for cross-browser adoption by developers. As such, performance won't and shouldn't be your primary concern. What's more, sometimes creating prollyfills for experimental APIs require us to do bad things to HTML, JavaScript and CSS in order to create something halfway functional, and these bad things often cause performance go fly right out the window. Chalk this up to another reason why access to those "low-level APIs" described in the Extensible Web Manifesto are so critical, as these would allow developers to build prollyfills that also perform reasonably well. Until then, we do the best we can.

Of course, just because performance isn't your primary concern when building a prollyfill doesn't mean it shouldn't be a concern, at all. While I don't recommend spending time building comparative JSPerf tests and mining your browser's developer tools in an effort to squeeze out that extra few dozen milliseconds of speed, it is important to pay at least some attention to how your library performs, and apply common-sense practices to it's construction. In this section, we'll take a look at a couple of simple refactoring steps I can perform to quickly improve the overall performance of my prolyfill.

[PERF SECTION]

[CLOSING]
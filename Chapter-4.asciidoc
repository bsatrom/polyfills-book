[[polyfills_chapter_3]]
== Building Your First Polyfill, Part 1 - Getting Started

Over the last two chapters, we laid some groundwork with a discussion on why polyfilling is still important, and some principles for responsible polyfill development. With that out of the way, let's get practical and start building a polyfill of our own, shall we? In this chapter, I'm going to walk through some practical steps for building cross-browser polyfills via an actual, real-world project that I've been working on for the last several months. We won't go through every line of code, or every excruciating detail, but I will introduce you to some practical examples and considerations that you'll want to keep in mind for your own polyfill development, no matter the technology being targeted. We'll start with a discussion on project setup and structure before diving into setting up your API and deciding what you plan to build and not to build. Then we'll explore adding basic features and refactoring your polyfill as you expand scope over time. We'll then wrap up the chapter with a look at manual cross-browser testing, and some tips for streamlining your cross-browser testing workflow. 

=== The HTML5 Forms Polyfill

First, let's take a look at our candidate library for the next two chapters: an HTML5 Forms polyfill. When I first set out to write this book, I considered a lot of different options for a guinea pig polyfill to use. I wanted to target something that was reasonably complex, but straightforward enough to introduce in bits and pieces, via text. I also wanted to choose a technology that’s implementation status across browsers was more than just "supported in everything but IE." And even though IE will factor into some of the hairier aspects of our polyfill development, I wanted to walk through an example with quirks in as many browsers as possible. For those purposes, there’s no better technology to attempt to polyfill than "HTML5 Forms."

What we know of today as "http://www.w3.org/TR/2011/WD-html5-20110525/forms.html[HTML5 forms]" was actually the first technology to be proposed under the umbrella of what we refer to as "HTML5." First introduced outside of the WC3 as "Web Forms 2.0" by a consortium of browser vendors that included Google, Mozilla, Opera Software and Apple, this proposal arrived at a time when the W3C was still pouring much of their effort into the now-deduct XHTML 2.0. As an outflow of "Web Forms 2.0," these vendors formed the Web Hypertext Application Technology Working Group (WHATWG), a sibling standards body to the W3C that still exists today.

And while it’s outside of the scope of this book to discuss the politics of HTML5, various collected standards and competing standards bodies, it is important to note that HTML5 forms has not only been around a while, but it’s still one of the most hotly-debated aspects of the HTML5 spec. Certain aspects of the forms spec have near universal support (i.e. forms validation), some of the more visual aspects of the spec—new input types like number, color and datetime—have yet to be consistently implemented across all browsers. What’s more, in some cases for those browsers that do support certain types, the specifics of said support are often inconsistent from one implementation to the next, meaning that you, the developer, might not get exactly the behavior you expect, every time.

HTML5 Forms is a minefield. What better area to venture into as a polyfill developer, then, right? It’s a bit hairy, for sure, but this area of the spec if sufficiently complex enough to expose many of the polyfilling practices that I introduced in the last chapter.

In addition to targeting HTML5 Forms with my polyfill, I've chosen to leverage http://kendoui.com[Kendo UI] to provide much of the functionality that my polyfill will deliver to older browsers, from visual elements like Color and Date pickers, to key framework-level features like form validation. Ad though Kendo UI is commonly used as a commercially-licensed suite, all of the UI widgets and framework features I need for my polyfill are available in the Open Source licensed version of Kendo UI Web (GPLv3), which is available from http://www.kendoui.com[the website].  

=== Setting Up Your Polyfill Project

Regardless of the technology you choose to target with your polyfill, the two most important choices that you can make early on are: 1) which source control solution you plan to use and b) what your initial project structure shouls look like. Sure, you can start with "Source Control by Dropbox" at the beginning and name your polyfill +mylib.js+ if you're just itching to get started, but a little bit of foresight and planning is, in my opinion, just as important to polyfill development as the code you write, so I'll spend a few moments talking about these early considerations.

==== Choosing  Source Control Solution

The first step is to think about how and where you’ll want to host your code so that a) you’ve got a backup and full project history in case things go wrong and b) other developers can find, leverage and contribute to your project. For the first part, you’ll want to choose a source control solution that’s open-source and widely-used. Two examples are http://git-scm.com/[Git] and http://mercurial.selenic.com/[Mercurial]. These two systems have a similar command-line syntax for working with files and code repositories, so some developers are comfortable working with either. That said, Git is far and away the most popular source control system in use today, so you’ll reach a larger body of potential collaborators by choosing that system.

When paired with a solid code-sharing site, your source control solution also gives you a platform for making your polyfill available to the world. Not only can you store your polyfill source and history in these sites, but you can make that source and history available for others, which is hopefully your goal as a polyfill developer. Just as Git is the most popular source control option around today, https://github.com/[GitHub] is the most popular option for hosting and collaborating on all manner of git-based open-source software projects. Other options worth considering, if GitHub is not your cup of tea are http://www.bitbucket.com/[BitBucket]--which allows you to host both Git and Mercurial projects—and Microsoft’s http://www.codeplex.com/[CodePlex]--which supports Mercurial projects only. For the examples in this book, I’ve chosen Git as my source control solution and GitHub for code sharing and distribution.

==== Setting up the Initial Project Structure

Once I've chosen a source control solution, I'm ready to set up my project. I do all of my development in a folder called +Development+ on my Mac, so that's where I'l create a new folder for my polyfill, called +kendo-ui-forms+. Then, I'll open a terminal windows in that directory and initialize a new GitHub repo by running the +git init+ command. Once you’ve initialized your local git repository, you’ll want to connect it to the remote repository that will be hosting your project online, which you can do by running the +git remote add git@github.com:_yourusername_/_your-project-name_.git+.

With that done, your local and remote repositories will be all set-up and it will be time to add some essential project files. Here's the basic project structure I recommend for most open-source polyfills (assuming a view from the folder root):

- +dist/+ - The minified and concatenated files you plan to distribute; i.e. the "binaries" for your polyfill
- +lib/+ - Any 3rd-party libraries that your Polyfill depends on (jQuery, Underscore, etc.)
- +sample/+ - The sample project for the polyfill
- +spec/+ - Home for your unit tests, which we'll discuss in Chapter 4
- +src/[js,css]+ - Source JavaScript and CSS files
- +.gitignore+ - A list of files for Git to ignore when found in your project. GitHub can create one of these files for you when creating a new project. If you go that route, select the "Node" template.
- +CHANGELOG.md+ - A laundry-list of minor and breaking changes for each version of your project. 
- +CONTRIBUTING.md+ - Essential if you plan to accept contributions for your project. 
- +README.md+ - the readme for your project. GitHub automatically treats this file as the main entry point when anyone visits your project. It should describe the purpose and goals of the polyfill--as I discussed in Chapter 1--features of the project, a roadmap for the projects, installation and usage instructions and anything else you think might be useful to consumers of or collaborators on your polyfill.
- +LICENSE.md+ - Every open-source project needs a license. Which license you choose is up to you, but permissive licenses, such as MIT and Apache 2.0 will garner more interest and, possibly, participation from other developers. GitHub can also generate this file for you, based on the license chosen at project creation. 

[NOTE]
====
The advice of a no-talent hack, such as yours truly, should not be confused for legal expertise. As such, your best bet is to consult with a legal expert before choosing an open source license. You can also visit the great http://choosealicense.com/[ChooseALicense.com] for more information about the dizzying array of open-source licenses available. But still, you should talk to a lawyer if you want an expert legal perspective in your choice of license. 
====

=== Specifying the API

Once your polyfill project is set-up, your next important decision is determining how other developers will "call" your polyfill, if at all. As you'll recall from Chapter 1, two of the important "sub types" of polyfills are the "opt in" and "drop in" types. If you're building a "drop in" polyfill, that essentially means that developers need only include a reference to your library in their projects. When your script is loaded, it automatically "activates" and goes to work. For these types of polyfills, the API of your library is straightforward and should match the API of the specced functionality you're emulating, as much as possible.

If, on the other hand, you're building an "opt-in" polyfill, you'll need to provide some mechanism for developers to activate your library. How you choose to expose your polyfill to developers is up to you, but I recommend considering your audience, specifically what they are likely to expect and be comfortable with, as your design your API. For examples of how other libraries expose their "opt-in" APIs, you can check out examples on the https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills[Modernizr Polyfill List] Since the HTML5 Forms polyfill I'm building will leverage Kendo UI, I've chosen to build my polyfill as a custom Kendo UI Widget. What's more, by building my polyfill as a Kendo UI widget, I can use Kendo UI's ready made options for initializing my library. As a result, I gain an initialization API for my polyfill that's easy to use and familiar to many developers.

Kendo UI allows developers to initialize widgets in one of two ways. I can use jQuery-style widget initialization, as illustrated in <<EX3-1>>, or I can use a declarative-style declaration, which hinges on placing +data-role+ attributes on relevant elements in my markup. This approach is illustrated in <<EX3-2>>.

[[EX3-1]]
 .Initializing the Forms polyfill using JavaScript
====
[source, js]
----
<form id="myForm">
  <!-- Rest of form declaration -->
</form>
<script>
  $('#myForm').kendoForm();
</script>
----
====

[[EX3-2]]
.Initializing the Forms polyfill via declarative initialization
====
[source, js]
----
<form action="input.html" data-role="form">
  <!-- Rest of form declaration -->
</form>
<script>
  kendo.init(document.body);
</script>
----
====

To support both of these approaches in my polyfill, I'll need to follow Kendo UI's recommended approach for creating custom Kendo UI widgets. First, I'll create the core source file for my polyfill in the +src/+ folder for my project. I'll call it +kendo.forms.js+, which follows a naming convention similar to other Kendo UI source files. Then, in my new source file, I'll include the code in <<EX3-3>>.

[[EX3-3]]
.Initial skeleton for the Kendo UI Forms Polyfill
====
[source, js]
----
(function($, kendo) {
  var ui = kendo.ui,
    Widget = ui.Widget;
    
  var Form = Widget.extend({
    init: function(element, options) {
      // base call to widget initialization
      Widget.fn.init.call(this, element, options);
    },
    options: {
      // the name is what it will appear in the kendo namespace (kendo.ui.Form).
      // The jQuery plugin would be jQuery.fn.kendoForm.
      name: 'Form'
    }
  });

  ui.plugin(Form);
} (jQuery, kendo));
----
====

As you can see from the code above, my polyfill starts with an IIFE that specifies my dependencies, jQuery and Kendo UI in this case. Next, I create some local lookup variables to cache key parts of the Kendo UI namespace. Then, I create a new Form variable by calling the +kendo.ui.Widget.extend+ method, which takes care of handling the initialization types I specified above. Finally, I'll call the +kendo.ui.plugin+ method and pass in my +Form+ widget, which adds my Polyfill to the widget registry for runtime lookup and evaluation.

For my HTML5 Forms polyfill, this is all I need to create a public API for initializing my library. With this skeleton code in place, I can now use either initialization method described in <<EX3-1>> and <<EX3-2>> and things will resolve. My polyfill won't do anything at this point, but it will run without errors, so that's progress!

With the opt-in API of our library set, we can move on to building out the core functionality of our polyfill. Regardless of the type of polyfill you're building, much of the API you'll be exposing should already be decided for you via the specification for the technology you're targeting. As discussed in the last chapter, it's important to adhere to this specification as much as possible. If you're planning to support an aspect of the spec, you should try your best to support it _as specced_. You should also be clear in your documentation and in source comments which aspects of the spec you support and which you don't. 

=== Deciding what to build

Speaking of which, the next important decision you need to make in your library is what to build. Even if you do plan to support every nook and cranny of a spec with your polyfill, you probably won't be able to bang out full support over a weekend. You need a plan, and if you're anything like me, you probably want to target simple features and "quick wins" first, building a good foundation and a working polyfill before tackling the hairier aspects of support. If you'd rather target the hard stuff first, that's ok too, of course!

In the context of HTML5 Forms, the simpler features are those new input types like Color, Number and DateTime. Because Kendo UI Web has widgets for these, "supporting" them is a simple matter of adding the Kendo UI widget when one of these types is found on a form. Validation support, on the other hand, is a bit trickier, so Im going to put that off for later, perhaps after the first couple of releases.

Since we're talking about releases, this is probably a good time to think about the roadmap for your polyfill. Assuming you're talking a complex feature, you'll probably want to write down what you plan to support, and when. For the HTML5 Forms polyfill, I chose to include a roadmap on the README for the project, which I've also included below in <<EX3-4>>.

[[EX3-4]]
TODO: TABLE with roadmap 

In addition to creating a roadmap and plan for your polyfill, you'll also want to consider if there's anything under the technology umbrella that you're planning to polyfill that you don't plan to or cannot support. Sometimes, it's not possible to reliably polyfill an aspect of a specification, so you'll want to avoid even trying to support it. Other times, adding support for a given feature is possible, but not something you're prepared to take on. No matter the reason, be sure that your roadmap is clear about what you're not planning to polyfill so that developers are informed when considering your library. 

=== Adding Basic Features

Ok, so we've got our basic polyfill skeleton in place, an API for calling it and a roadmap for which features we plan to add. Now it's time to get to work and add our first, real feature. Of course, if we're going to add features to our polyfill, we also need ways to test them out, don't we? IN Chapter 4, I'll discuss setting up unit and cross-browser testing in-depth, but in the meantime, let's create a "sample" form that we can use to test out our library as we work on it. This sample will serve as a live demonstration and part of our docs when we publish our polyfill, so it's something you'll want to add to your projects even if you're also performing automated or unit testing.

To that end, let's create a new HTML page in the +samples/+ folder and call it form-sample.html. Since our library is an HTML5 Forms polyfill, it makes sense that the sample page itself be a form. Since this sample page will also seve as a part of my docs, the HTML page will include references to bootstrap and some additional markup. Beyond that, the relevant portion of this sample page, that is the form itself is shown in <<EX3-4>>.

[[EX3-04]]
.Polyfill sample form markfup
====
[source, html]
----
<!-- TODO -->
----
====

As you can see from the sample, it's a pretty robust form, and it also uses pretty much all of the new HTML5 Forms features introduced in the spec. 

- Creating the Sample / Test Form
- Creating the skeleton for the polyfill (as a Kendo UI Widget) [also grab from Chapter 3]
- Adding the first feature (support for the color type)
- Adding Feature Detection and an "Always Use" mode

  ==== To Feature Detect, or Not to Feature Detect

  - First thing to consider when starting development
  - Ways to support handle optional feature detection

=== Expanding your Polyfill and Refactoring

- Adding the second feature (support for the numeric type)
- Refactoring type support for consistency and ease of maintenance
- Adding features 3-n
- When things get hairy, adding support for date types

=== Polyfilling visual features with CSS

- Show the addition of CSS and JavaScript to add support for the "placeholder" attribute
- Talk about cross-browser quirks that arose and how to address those

=== Testing out your work across browsers

- Running your sample project in "Evergreen" Chrome, Safari, Firefox, Opera and IE
- Testing oldIE with VMs from modern.ie
- Testing across browsers with browserstack, testling, etc.

=== Conclusion

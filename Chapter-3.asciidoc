[[polyfills_chapter_3]]
== Building Your First Polyfill, Part 1 - Setup and Testing

Over the first two chapters of this book, we've established a good foundation for polyfill development, first by discussing the continuing importance of polyfilling to the web platform in Chapter 1. In Chapter 2, I shared some essential principles to keep in mind when building "responsible polyfills." Principles are nice, but you want some proof that these principles work, don't you? With that in mind, let's turn our attention to the construction of a real world cross-browser polyfill: an HTML5 Forms polyfill. 

Over the next two chapters, we'll take a deep-dive look at the creation of an actual polyfill. In this chapter, we'll look at some good practices for setting up your project, and how to configure your dev environment for automated cross-browser testing.

=== The HTML5 Forms Polyfill

When I first set out to write this book, I considered a lot of different options for a good candidate polyfill to introduce. I wanted to target something that was reasonably complex, but straightforward enough to introduce in bits and pieces via text. I also wanted to choose a technology that's implementation status across browsers was more than just "supported in everything but IE." And even though IE will factor into some of the hairier aspects of our polyfill development, I wanted to walk through an example with quirks in as many browsers as possible. For those purposes, there's no better technology to attempt to polyfill than "HTML5 Forms."

First, a bit of history. What we know today as "http://www.w3.org/TR/2011/WD-html5-20110525/forms.html[HTML5 forms]" was actually the first technology to be proposed under the umbrella of what we refer to as "HTML5." First introduced outside of the WC3 as "Web Forms 2.0" by a consortium of browser vendors that included Google, Mozilla, Opera Software and Apple, this proposal arrived at a time when the W3C was still pouring much of their effort into the now-deduct XHTML 2.0. Around this same time, these vendors formed the Web Hypertext Application Technology Working Group (WHATWG), a sibling standards body to the W3C that still exists today. 

And while it's outside of the scope of this book to discuss the politics of HTML5 and various collected standards, it's important to note that HTML5 forms has not only been around a while, but it's still one of the most hotly-debated aspects of the HTML5 spec. And while certain aspects of forms support have near universal support (as form validation does across all modern browsers), some of the more visual aspects of the spec, meaning new input types like number, color and datetime, have yet to be consistently implemented across all browsers. Better still, for those browsers that do support certain types, the specifics of said support are occasionally lacking, as in you might not get exactly the behavior you expect.

What better area of HTML5 to venture into as a polyfill developer, no? It's a bit of a minefield for sure, but this area of the spec if sufficiently complex enough to expose many of the polyfilling practices that I introduced in the last chapter. 

=== Setting up Your Polyfill project

When starting work on a cross-browser polyfill, you want to begin with the end in mind. That is, before you write a single line of code, you should think about how you plan to distribute your hard work, and how you expect other developers to leverage your polyfill in their apps, and even how you can enable others to contribute to your project. All of these considerations can be addressed at the start of your project with a solid development workflow, which includes several core pieces.

==== 1. Source control and collaboration

The first step is to think about how and where you'll want to host your code so that a) you've got a backup and full project history in case things go wrong and b) other developers can find, leverage and contribute to your project. For the first part, you'll want to choose a source control solution that's open-source and widely-used. Two examples are http://git-scm.com[Git] and http://mercurial.selenic.com/[Mercurial]. These two systems have a similar command-line syntax for working with files and code repositories, so some developers are comfortable working with either. That said, Git is far and away the most popular source control system in use today, so you'll reach a larger body of potential collaborators by sticking with this system.

When paired with a solid code-sharing site, your source control solution also gives you a platform for making your polyfill available to the world. Not only can you store your polyfill source and history in these sites, but you can make that source and history available for others, which is hopefully your goal as a Polyfill developer. Much as Git is the most popular source control option around today, http://github.com[GitHub] is the most popular option for hosting and collaborating on all manner of open-source software projects. Other options worth considering, if GitHub is not your cup of tea are http://www.bitbucket.com[BitBucket]--which allows you to host both Git and Mercurial projects--and Microsoft's http://www.codeplex.com/[CodePlex]--which supports Mercurial projects only. For the examples in this book, I've chosen Git as my source control solution and GitHub for code sharing and distribution.

==== 2. Package and Dependency Management

Once you've chosen a source control solution, you'll want to think about how to manage dependencies. By dependencies, I'm not referring to "this polyfill depends on jQuery," but, rather, the 3rd party libraries that your polyfill depends on for things like static analysis, minification, testing and more. We'll talk about those specific tools in a bit, but before you start using them, you need to think about how you plan to include them in your project, and declare those dependencies for others who download your work. In the world of JavaScript development, there's no better general-purpose package manager than http://npmjs.org[NPM], the Node.js Package Manager. If you have http://nodejs.org[Node.js] installed, you already have npm. If not, head over to http://nodejs.org and grab the appropriate installer for your OS. You'll be using Node and NPM heavily throughout your polyfill project. These tools are also a prerequisite for the next few items on our list.

==== 3. Build and Workflow Management

Developing open-source software, including Polyfills, is about more than just throwing together a quick sample, some basic tests and a source file. Sure, it's possible to put something online that consists of only these things, I've even done it myself before. Five years ago, it was even a common practice among the front-end community. But as our community has matured, our tools and our processes have evolved, as well. Perhaps one could even make the argument that our tools have matured us, but that's neither here nor there. 

As a front-end developer, I have a workflow that's shared by many others. I write tests. I write code until those tests pass. I repeat. I test across browsers. I write some more code. During development, I keep my source files small and separate, but I want the code I distribute to be in a single file, minified and ready to use in production environments.

Executing all of these tasks by hand is a pain. Thankfully, there are great build and workflow tools out there for front-end devs. These tools, which you integrate into your project in one way or another, can quickly perform these tasks on your behalf, either at your command, or when a change to a project file is observed.

Once such tool is http://gruntjs.com/[Grunt], a simple JavaScript task runner created by Ben Alman. Grunt is a bit of a youngster in the build system world, but it's caught fire among front-end developers and, with lots of community participation, has managed to achieve some stability in just a short time.

I use grunt in my projects , and will do so in this book as well. The tool can be installed via npm. For more information, see the online http://gruntjs.com/getting-started[getting started guide]. We'll walkthrough configuring an initial grunt setup in a moment.  

==== 4. Automated and Cross-Browser Testing

If you're building a front-end library, testing is important. Vitally important if you building a shim or Polyfill! Almost every programming language out there has one or more options for unit testing, and JavaScript is no different. Unit testing, that is, the act of writing and executing code that exercises program code and performs assertions to verify that the program functioned as expected, has become quite popular over the last decade, especially in Agile, eXtreme Programming and Lean Software circles. Not only does unit testing aid the developer in properly shaping the API and behavior of his or her library by writing code (the tests) in the mindset of the consumer, but a suite of tests, over time, serve as a wonderful safety net. With this net in place a developer is free to refactor, reword and otherwise enhance her library, and remain confident in the fact that her tests will catch and regressions that fall through the cracks.

In the world of JavaScript development, there are countless unit testing libraries. I prefer http://pivotal.github.io/jasmine/[Jasmine] a "BDD-style" unit testing library. Other popular options include http://qunitjs.com[QUnit], which is maintained by the jQuery team, and https://github.com/caolan/nodeunit/[NodeUnit].

Of course, unit testing is great, but we also need to consider cross-browser testing for this project. It is a cross-browser polyfill. As such, our project will also need to include an automated tool that can launch multiple browsers and load our unit tests up in each, thereby ensuring at least basic test coverage across browsers. The tool that I prefer to use for such a task is http://karma-runner.github.io/0.10/index.html[Karma], which you can also install via NPM. There's a bit of setup involved in getting Karma up and running the way I like, and we'll cover that below.

=== 5. Continuous Integration  

The last tool you need to consider for your initial project setup is a remote CI server. This step is completely optional, so if you want to take my advice on items 1-4 and ignore me on this one, that's ok. That said, the biggest advantage of a remote CI server for an open-source project is, in my mind, the ability to run basic project setup and unit tests in a clean environment. Doing so ensures that you properly declare dependencies via npm and that you never check-in code that fails one or more tests and just walk away. In my mind, it's better to get the news that you did something wrong from a CI server than from a human.

For my projects, I prefer to use https://travis-ci.org/[Travis], a CI server that many in the open-source community use as well. it's easy to set-up and configure, and you can even place status badges on your project's home page signifying it's current pass/fail status on the server. Another, newer option that I've recently discovered is http://wercker.com/[Wercker]. I'll be using Travis for this book, but Wercker is certainly worth checking out for your next project, open source or otherwise.

=== Initial Project Structure

Once you've made all of the appropriate tool choices, from source control to your build system, you're ready to create your project! For the rest of the book I'll be using the tools I indicated in each section above, so if you're choosing otherwise and following along, you might need to adjust things here and there to get the same result.

First

=== Configuring Unit Tests with Jasmine

=== Configuring Cross-Browser Tests with Karma

=== Automate your Polyfill Testing with Grunt and Travis-CI

=== To Feature Detect, or Not to Feature Detect

- First thing to consider when starting development
- Ways to support handle optional feature detection